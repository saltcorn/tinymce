/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/jsondiffpatch@0.5.0/dist/jsondiffpatch.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? e(exports, require("./empty"))
    : "function" == typeof define && define.amd
    ? define(["exports", "./empty"], e)
    : e(
        ((t =
          "undefined" != typeof globalThis
            ? globalThis
            : t || self).jsondiffpatch = {}),
        t.chalk
      );
})(this, function (t, e) {
  "use strict";
  class n {
    constructor(t) {
      (this.selfOptions = t || {}), (this.pipes = {});
    }
    options(t) {
      return t && (this.selfOptions = t), this.selfOptions;
    }
    pipe(t, e) {
      let n = e;
      if ("string" == typeof t) {
        if (void 0 === n) return this.pipes[t];
        this.pipes[t] = n;
      }
      if (t && t.name) {
        if (((n = t), n.processor === this)) return n;
        this.pipes[n.name] = n;
      }
      return (n.processor = this), n;
    }
    process(t, e) {
      let n = t;
      n.options = this.options();
      let r,
        i,
        s = e || t.pipe || "default";
      for (; s; )
        void 0 !== n.nextAfterChildren &&
          ((n.next = n.nextAfterChildren), (n.nextAfterChildren = null)),
          "string" == typeof s && (s = this.pipe(s)),
          s.process(n),
          (i = n),
          (r = s),
          (s = null),
          n && n.next && ((n = n.next), (s = i.nextPipe || n.pipe || r));
      return n.hasResult ? n.result : void 0;
    }
  }
  class r {
    constructor(t) {
      (this.name = t), (this.filters = []);
    }
    process(t) {
      if (!this.processor)
        throw new Error("add this pipe to a processor before using it");
      const e = this.debug,
        n = this.filters.length,
        r = t;
      for (let t = 0; t < n; t++) {
        const n = this.filters[t];
        if (
          (e && this.log(`filter: ${n.filterName}`),
          n(r),
          "object" == typeof r && r.exiting)
        ) {
          r.exiting = !1;
          break;
        }
      }
      !r.next && this.resultCheck && this.resultCheck(r);
    }
    log(t) {
      console.log(`[jsondiffpatch] ${this.name} pipe, ${t}`);
    }
    append() {
      return this.filters.push(...arguments), this;
    }
    prepend() {
      return this.filters.unshift(...arguments), this;
    }
    indexOf(t) {
      if (!t) throw new Error("a filter name is required");
      for (let e = 0; e < this.filters.length; e++) {
        if (this.filters[e].filterName === t) return e;
      }
      throw new Error(`filter not found: ${t}`);
    }
    list() {
      return this.filters.map((t) => t.filterName);
    }
    after(t) {
      const e = this.indexOf(t),
        n = Array.prototype.slice.call(arguments, 1);
      if (!n.length) throw new Error("a filter is required");
      return (
        n.unshift(e + 1, 0), Array.prototype.splice.apply(this.filters, n), this
      );
    }
    before(t) {
      const e = this.indexOf(t),
        n = Array.prototype.slice.call(arguments, 1);
      if (!n.length) throw new Error("a filter is required");
      return (
        n.unshift(e, 0), Array.prototype.splice.apply(this.filters, n), this
      );
    }
    replace(t) {
      const e = this.indexOf(t),
        n = Array.prototype.slice.call(arguments, 1);
      if (!n.length) throw new Error("a filter is required");
      return (
        n.unshift(e, 1), Array.prototype.splice.apply(this.filters, n), this
      );
    }
    remove(t) {
      const e = this.indexOf(t);
      return this.filters.splice(e, 1), this;
    }
    clear() {
      return (this.filters.length = 0), this;
    }
    shouldHaveResult(t) {
      if (!1 === t) return void (this.resultCheck = null);
      if (this.resultCheck) return;
      const e = this;
      return (
        (this.resultCheck = (t) => {
          if (!t.hasResult) {
            console.log(t);
            const n = new Error(`${e.name} failed`);
            throw ((n.noResult = !0), n);
          }
        }),
        this
      );
    }
  }
  class i {
    setResult(t) {
      return (this.result = t), (this.hasResult = !0), this;
    }
    exit() {
      return (this.exiting = !0), this;
    }
    switchTo(t, e) {
      return (
        "string" == typeof t || t instanceof r
          ? (this.nextPipe = t)
          : ((this.next = t), e && (this.nextPipe = e)),
        this
      );
    }
    push(t, e) {
      return (
        (t.parent = this),
        void 0 !== e && (t.childName = e),
        (t.root = this.root || this),
        (t.options = t.options || this.options),
        this.children
          ? ((this.children[this.children.length - 1].next = t),
            this.children.push(t))
          : ((this.children = [t]),
            (this.nextAfterChildren = this.next || null),
            (this.next = t)),
        (t.next = this),
        this
      );
    }
  }
  const s =
    "function" == typeof Array.isArray
      ? Array.isArray
      : (t) => t instanceof Array;
  function o(t) {
    if ("object" != typeof t) return t;
    if (null === t) return null;
    if (s(t)) return t.map(o);
    if (t instanceof Date) return new Date(t.getTime());
    if (t instanceof RegExp)
      return (function (t) {
        const e = /^\/(.*)\/([gimyu]*)$/.exec(t.toString());
        return new RegExp(e[1], e[2]);
      })(t);
    const e = {};
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = o(t[n]));
    return e;
  }
  class a extends i {
    constructor(t, e) {
      super(), (this.left = t), (this.right = e), (this.pipe = "diff");
    }
    setResult(t) {
      if (this.options.cloneDiffValues && "object" == typeof t) {
        const e =
          "function" == typeof this.options.cloneDiffValues
            ? this.options.cloneDiffValues
            : o;
        "object" == typeof t[0] && (t[0] = e(t[0])),
          "object" == typeof t[1] && (t[1] = e(t[1]));
      }
      return i.prototype.setResult.apply(this, arguments);
    }
  }
  class l extends i {
    constructor(t, e) {
      super(), (this.left = t), (this.delta = e), (this.pipe = "patch");
    }
  }
  class f extends i {
    constructor(t) {
      super(), (this.delta = t), (this.pipe = "reverse");
    }
  }
  const h =
      "function" == typeof Array.isArray
        ? Array.isArray
        : function (t) {
            return t instanceof Array;
          },
    c = function (t) {
      if (t.left !== t.right)
        if (void 0 !== t.left)
          if (void 0 !== t.right) {
            if ("function" == typeof t.left || "function" == typeof t.right)
              throw new Error("functions are not supported");
            (t.leftType = null === t.left ? "null" : typeof t.left),
              (t.rightType = null === t.right ? "null" : typeof t.right),
              t.leftType === t.rightType &&
              "boolean" !== t.leftType &&
              "number" !== t.leftType
                ? ("object" === t.leftType && (t.leftIsArray = h(t.left)),
                  "object" === t.rightType && (t.rightIsArray = h(t.right)),
                  t.leftIsArray === t.rightIsArray
                    ? t.left instanceof RegExp &&
                      (t.right instanceof RegExp
                        ? t
                            .setResult([t.left.toString(), t.right.toString()])
                            .exit()
                        : t.setResult([t.left, t.right]).exit())
                    : t.setResult([t.left, t.right]).exit())
                : t.setResult([t.left, t.right]).exit();
          } else t.setResult([t.left, 0, 0]).exit();
        else {
          if ("function" == typeof t.right)
            throw new Error("functions are not supported");
          t.setResult([t.right]).exit();
        }
      else t.setResult(void 0).exit();
    };
  c.filterName = "trivial";
  const u = function (t) {
    if (void 0 !== t.delta) {
      if (((t.nested = !h(t.delta)), !t.nested))
        if (1 !== t.delta.length)
          if (2 !== t.delta.length)
            3 === t.delta.length &&
              0 === t.delta[2] &&
              t.setResult(void 0).exit();
          else {
            if (t.left instanceof RegExp) {
              const e = /^\/(.*)\/([gimyu]+)$/.exec(t.delta[1]);
              if (e) return void t.setResult(new RegExp(e[1], e[2])).exit();
            }
            t.setResult(t.delta[1]).exit();
          }
        else t.setResult(t.delta[0]).exit();
    } else t.setResult(t.left).exit();
  };
  u.filterName = "trivial";
  const d = function (t) {
    void 0 !== t.delta
      ? ((t.nested = !h(t.delta)),
        t.nested ||
          (1 !== t.delta.length
            ? 2 !== t.delta.length
              ? 3 === t.delta.length &&
                0 === t.delta[2] &&
                t.setResult([t.delta[0]]).exit()
              : t.setResult([t.delta[1], t.delta[0]]).exit()
            : t.setResult([t.delta[0], 0, 0]).exit()))
      : t.setResult(t.delta).exit();
  };
  function p(t) {
    if (!t || !t.children) return;
    const e = t.children.length;
    let n,
      r = t.result;
    for (let i = 0; i < e; i++)
      (n = t.children[i]),
        void 0 !== n.result && ((r = r || {}), (r[n.childName] = n.result));
    r && t.leftIsArray && (r._t = "a"), t.setResult(r).exit();
  }
  function g(t) {
    if (t.leftIsArray || "object" !== t.leftType) return;
    let e, n;
    const r = t.options.propertyFilter;
    for (e in t.left)
      Object.prototype.hasOwnProperty.call(t.left, e) &&
        ((r && !r(e, t)) || ((n = new a(t.left[e], t.right[e])), t.push(n, e)));
    for (e in t.right)
      Object.prototype.hasOwnProperty.call(t.right, e) &&
        ((r && !r(e, t)) ||
          (void 0 === t.left[e] &&
            ((n = new a(void 0, t.right[e])), t.push(n, e))));
    t.children && 0 !== t.children.length
      ? t.exit()
      : t.setResult(void 0).exit();
  }
  (d.filterName = "trivial"),
    (p.filterName = "collectChildren"),
    (g.filterName = "objects");
  const m = function (t) {
    if (!t.nested) return;
    if (t.delta._t) return;
    let e, n;
    for (e in t.delta) (n = new l(t.left[e], t.delta[e])), t.push(n, e);
    t.exit();
  };
  m.filterName = "objects";
  const v = function (t) {
    if (!t || !t.children) return;
    if (t.delta._t) return;
    const e = t.children.length;
    let n;
    for (let r = 0; r < e; r++)
      (n = t.children[r]),
        Object.prototype.hasOwnProperty.call(t.left, n.childName) &&
        void 0 === n.result
          ? delete t.left[n.childName]
          : t.left[n.childName] !== n.result &&
            (t.left[n.childName] = n.result);
    t.setResult(t.left).exit();
  };
  v.filterName = "collectChildren";
  const y = function (t) {
    if (!t.nested) return;
    if (t.delta._t) return;
    let e, n;
    for (e in t.delta) (n = new f(t.delta[e])), t.push(n, e);
    t.exit();
  };
  function _(t) {
    if (!t || !t.children) return;
    if (t.delta._t) return;
    const e = t.children.length;
    let n;
    const r = {};
    for (let i = 0; i < e; i++)
      (n = t.children[i]),
        r[n.childName] !== n.result && (r[n.childName] = n.result);
    t.setResult(r).exit();
  }
  (y.filterName = "objects"), (_.filterName = "collectChildren");
  const x = function (t, e, n, r) {
    return t[n] === e[r];
  };
  var b = function (t, e, n, r) {
    const i = r || {},
      s = (function (t, e, n, r) {
        const i = t.length,
          s = e.length;
        let o, a;
        const l = [i + 1];
        for (o = 0; o < i + 1; o++)
          for (l[o] = [s + 1], a = 0; a < s + 1; a++) l[o][a] = 0;
        for (l.match = n, o = 1; o < i + 1; o++)
          for (a = 1; a < s + 1; a++)
            n(t, e, o - 1, a - 1, r)
              ? (l[o][a] = l[o - 1][a - 1] + 1)
              : (l[o][a] = Math.max(l[o - 1][a], l[o][a - 1]));
        return l;
      })(t, e, n || x, i),
      o = (function (t, e, n, r) {
        let i = e.length,
          s = n.length;
        const o = { sequence: [], indices1: [], indices2: [] };
        for (; 0 !== i && 0 !== s; )
          t.match(e, n, i - 1, s - 1, r)
            ? (o.sequence.unshift(e[i - 1]),
              o.indices1.unshift(i - 1),
              o.indices2.unshift(s - 1),
              --i,
              --s)
            : t[i][s - 1] > t[i - 1][s]
            ? --s
            : --i;
        return o;
      })(s, t, e, i);
    return (
      "string" == typeof t &&
        "string" == typeof e &&
        (o.sequence = o.sequence.join("")),
      o
    );
  };
  const w =
      "function" == typeof Array.isArray
        ? Array.isArray
        : (t) => t instanceof Array,
    j =
      "function" == typeof Array.prototype.indexOf
        ? (t, e) => t.indexOf(e)
        : (t, e) => {
            const n = t.length;
            for (let r = 0; r < n; r++) if (t[r] === e) return r;
            return -1;
          };
  function D(t, e, n, r, i) {
    const s = t[n],
      o = e[r];
    if (s === o) return !0;
    if ("object" != typeof s || "object" != typeof o) return !1;
    const a = i.objectHash;
    if (!a) return i.matchByPosition && n === r;
    let l, f;
    return (
      "number" == typeof n
        ? ((i.hashCache1 = i.hashCache1 || []),
          (l = i.hashCache1[n]),
          void 0 === l && (i.hashCache1[n] = l = a(s, n)))
        : (l = a(s)),
      void 0 !== l &&
        ("number" == typeof r
          ? ((i.hashCache2 = i.hashCache2 || []),
            (f = i.hashCache2[r]),
            void 0 === f && (i.hashCache2[r] = f = a(o, r)))
          : (f = a(o)),
        void 0 !== f && l === f)
    );
  }
  const M = function (t) {
    if (!t.leftIsArray) return;
    const e = {
      objectHash: t.options && t.options.objectHash,
      matchByPosition: t.options && t.options.matchByPosition,
    };
    let n,
      r,
      i,
      s = 0,
      o = 0;
    const l = t.left,
      f = t.right,
      h = l.length,
      c = f.length;
    let u, d;
    for (
      h > 0 &&
      c > 0 &&
      !e.objectHash &&
      "boolean" != typeof e.matchByPosition &&
      (e.matchByPosition = !(function (t, e, n, r) {
        for (let i = 0; i < n; i++) {
          const n = t[i];
          for (let t = 0; t < r; t++) {
            const r = e[t];
            if (i !== t && n === r) return !0;
          }
        }
      })(l, f, h, c));
      s < h && s < c && D(l, f, s, s, e);

    )
      (n = s), (u = new a(t.left[n], t.right[n])), t.push(u, n), s++;
    for (; o + s < h && o + s < c && D(l, f, h - 1 - o, c - 1 - o, e); )
      (r = h - 1 - o),
        (i = c - 1 - o),
        (u = new a(t.left[r], t.right[i])),
        t.push(u, i),
        o++;
    if (s + o === h) {
      if (h === c) return void t.setResult(void 0).exit();
      for (d = d || { _t: "a" }, n = s; n < c - o; n++) d[n] = [f[n]];
      return void t.setResult(d).exit();
    }
    if (s + o === c) {
      for (d = d || { _t: "a" }, n = s; n < h - o; n++)
        d[`_${n}`] = [l[n], 0, 0];
      return void t.setResult(d).exit();
    }
    delete e.hashCache1, delete e.hashCache2;
    const p = l.slice(s, h - o),
      g = f.slice(s, c - o),
      m = b(p, g, D, e),
      v = [];
    for (d = d || { _t: "a" }, n = s; n < h - o; n++)
      j(m.indices1, n - s) < 0 && ((d[`_${n}`] = [l[n], 0, 0]), v.push(n));
    let y = !0;
    t.options &&
      t.options.arrays &&
      !1 === t.options.arrays.detectMove &&
      (y = !1);
    let _ = !1;
    t.options &&
      t.options.arrays &&
      t.options.arrays.includeValueOnMove &&
      (_ = !0);
    const x = v.length;
    for (n = s; n < c - o; n++) {
      const o = j(m.indices2, n - s);
      if (o < 0) {
        let o = !1;
        if (y && x > 0)
          for (let l = 0; l < x; l++)
            if (((r = v[l]), D(p, g, r - s, n - s, e))) {
              d[`_${r}`].splice(1, 2, n, 3),
                _ || (d[`_${r}`][0] = ""),
                (i = n),
                (u = new a(t.left[r], t.right[i])),
                t.push(u, i),
                v.splice(l, 1),
                (o = !0);
              break;
            }
        o || (d[n] = [f[n]]);
      } else
        (r = m.indices1[o] + s),
          (i = m.indices2[o] + s),
          (u = new a(t.left[r], t.right[i])),
          t.push(u, i);
    }
    t.setResult(d).exit();
  };
  M.filterName = "arrays";
  const A = {
      numerically: (t, e) => t - e,
      numericallyBy: (t) => (e, n) => e[t] - n[t],
    },
    $ = function (t) {
      if (!t.nested) return;
      if ("a" !== t.delta._t) return;
      let e, n;
      const r = t.delta,
        i = t.left;
      let s = [],
        o = [];
      const a = [];
      for (e in r)
        if ("_t" !== e)
          if ("_" === e[0]) {
            if (0 !== r[e][2] && 3 !== r[e][2])
              throw new Error(
                `only removal or move can be applied at original array indices, invalid diff type: ${r[e][2]}`
              );
            s.push(parseInt(e.slice(1), 10));
          } else
            1 === r[e].length
              ? o.push({ index: parseInt(e, 10), value: r[e][0] })
              : a.push({ index: parseInt(e, 10), delta: r[e] });
      for (s = s.sort(A.numerically), e = s.length - 1; e >= 0; e--) {
        n = s[e];
        const t = r[`_${n}`],
          a = i.splice(n, 1)[0];
        3 === t[2] && o.push({ index: t[1], value: a });
      }
      o = o.sort(A.numericallyBy("index"));
      const f = o.length;
      for (e = 0; e < f; e++) {
        const t = o[e];
        i.splice(t.index, 0, t.value);
      }
      const h = a.length;
      let c;
      if (h > 0)
        for (e = 0; e < h; e++) {
          const n = a[e];
          (c = new l(t.left[n.index], n.delta)), t.push(c, n.index);
        }
      t.children ? t.exit() : t.setResult(t.left).exit();
    };
  $.filterName = "arrays";
  const R = function (t) {
    if (!t || !t.children) return;
    if ("a" !== t.delta._t) return;
    const e = t.children.length;
    let n;
    for (let r = 0; r < e; r++)
      (n = t.children[r]), (t.left[n.childName] = n.result);
    t.setResult(t.left).exit();
  };
  R.filterName = "arraysCollectChildren";
  const C = function (t) {
    if (!t.nested)
      return void (
        3 === t.delta[2] &&
        ((t.newName = `_${t.delta[1]}`),
        t
          .setResult([t.delta[0], parseInt(t.childName.substr(1), 10), 3])
          .exit())
      );
    if ("a" !== t.delta._t) return;
    let e, n;
    for (e in t.delta) "_t" !== e && ((n = new f(t.delta[e])), t.push(n, e));
    t.exit();
  };
  C.filterName = "arrays";
  const E = (t, e, n) => {
    if ("string" == typeof e && "_" === e[0]) return parseInt(e.substr(1), 10);
    if (w(n) && 0 === n[2]) return `_${e}`;
    let r = +e;
    for (const n in t) {
      const i = t[n];
      if (w(i))
        if (3 === i[2]) {
          const t = parseInt(n.substr(1), 10),
            s = i[1];
          if (s === +e) return t;
          t <= r && s > r ? r++ : t >= r && s < r && r--;
        } else if (0 === i[2]) {
          parseInt(n.substr(1), 10) <= r && r++;
        } else 1 === i.length && n <= r && r--;
    }
    return r;
  };
  function k(t) {
    if (!t || !t.children) return;
    if ("a" !== t.delta._t) return;
    const e = t.children.length;
    let n;
    const r = { _t: "a" };
    for (let i = 0; i < e; i++) {
      n = t.children[i];
      let e = n.newName;
      void 0 === e && (e = E(t.delta, n.childName, n.result)),
        r[e] !== n.result && (r[e] = n.result);
    }
    t.setResult(r).exit();
  }
  k.filterName = "arraysCollectChildren";
  const O = function (t) {
    t.left instanceof Date
      ? (t.right instanceof Date
          ? t.left.getTime() !== t.right.getTime()
            ? t.setResult([t.left, t.right])
            : t.setResult(void 0)
          : t.setResult([t.left, t.right]),
        t.exit())
      : t.right instanceof Date && t.setResult([t.left, t.right]).exit();
  };
  function T(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  }
  O.filterName = "dates";
  var N = { exports: {} };
  !(function (t) {
    var e = function () {
        (this.Diff_Timeout = 1),
          (this.Diff_EditCost = 4),
          (this.Match_Threshold = 0.5),
          (this.Match_Distance = 1e3),
          (this.Patch_DeleteThreshold = 0.5),
          (this.Patch_Margin = 4),
          (this.Match_MaxBits = 32);
      },
      n = -1;
    (e.Diff = function (t, e) {
      return [t, e];
    }),
      (e.prototype.diff_main = function (t, n, r, i) {
        void 0 === i &&
          (i =
            this.Diff_Timeout <= 0
              ? Number.MAX_VALUE
              : new Date().getTime() + 1e3 * this.Diff_Timeout);
        var s = i;
        if (null == t || null == n) throw new Error("Null input. (diff_main)");
        if (t == n) return t ? [new e.Diff(0, t)] : [];
        void 0 === r && (r = !0);
        var o = r,
          a = this.diff_commonPrefix(t, n),
          l = t.substring(0, a);
        (t = t.substring(a)),
          (n = n.substring(a)),
          (a = this.diff_commonSuffix(t, n));
        var f = t.substring(t.length - a);
        (t = t.substring(0, t.length - a)), (n = n.substring(0, n.length - a));
        var h = this.diff_compute_(t, n, o, s);
        return (
          l && h.unshift(new e.Diff(0, l)),
          f && h.push(new e.Diff(0, f)),
          this.diff_cleanupMerge(h),
          h
        );
      }),
      (e.prototype.diff_compute_ = function (t, r, i, s) {
        var o;
        if (!t) return [new e.Diff(1, r)];
        if (!r) return [new e.Diff(n, t)];
        var a = t.length > r.length ? t : r,
          l = t.length > r.length ? r : t,
          f = a.indexOf(l);
        if (-1 != f)
          return (
            (o = [
              new e.Diff(1, a.substring(0, f)),
              new e.Diff(0, l),
              new e.Diff(1, a.substring(f + l.length)),
            ]),
            t.length > r.length && (o[0][0] = o[2][0] = n),
            o
          );
        if (1 == l.length) return [new e.Diff(n, t), new e.Diff(1, r)];
        var h = this.diff_halfMatch_(t, r);
        if (h) {
          var c = h[0],
            u = h[1],
            d = h[2],
            p = h[3],
            g = h[4],
            m = this.diff_main(c, d, i, s),
            v = this.diff_main(u, p, i, s);
          return m.concat([new e.Diff(0, g)], v);
        }
        return i && t.length > 100 && r.length > 100
          ? this.diff_lineMode_(t, r, s)
          : this.diff_bisect_(t, r, s);
      }),
      (e.prototype.diff_lineMode_ = function (t, r, i) {
        var s = this.diff_linesToChars_(t, r);
        (t = s.chars1), (r = s.chars2);
        var o = s.lineArray,
          a = this.diff_main(t, r, !1, i);
        this.diff_charsToLines_(a, o),
          this.diff_cleanupSemantic(a),
          a.push(new e.Diff(0, ""));
        for (var l = 0, f = 0, h = 0, c = "", u = ""; l < a.length; ) {
          switch (a[l][0]) {
            case 1:
              h++, (u += a[l][1]);
              break;
            case n:
              f++, (c += a[l][1]);
              break;
            case 0:
              if (f >= 1 && h >= 1) {
                a.splice(l - f - h, f + h), (l = l - f - h);
                for (
                  var d = this.diff_main(c, u, !1, i), p = d.length - 1;
                  p >= 0;
                  p--
                )
                  a.splice(l, 0, d[p]);
                l += d.length;
              }
              (h = 0), (f = 0), (c = ""), (u = "");
          }
          l++;
        }
        return a.pop(), a;
      }),
      (e.prototype.diff_bisect_ = function (t, r, i) {
        for (
          var s = t.length,
            o = r.length,
            a = Math.ceil((s + o) / 2),
            l = a,
            f = 2 * a,
            h = new Array(f),
            c = new Array(f),
            u = 0;
          u < f;
          u++
        )
          (h[u] = -1), (c[u] = -1);
        (h[l + 1] = 0), (c[l + 1] = 0);
        for (
          var d = s - o, p = d % 2 != 0, g = 0, m = 0, v = 0, y = 0, _ = 0;
          _ < a && !(new Date().getTime() > i);
          _++
        ) {
          for (var x = -_ + g; x <= _ - m; x += 2) {
            for (
              var b = l + x,
                w =
                  ($ =
                    x == -_ || (x != _ && h[b - 1] < h[b + 1])
                      ? h[b + 1]
                      : h[b - 1] + 1) - x;
              $ < s && w < o && t.charAt($) == r.charAt(w);

            )
              $++, w++;
            if (((h[b] = $), $ > s)) m += 2;
            else if (w > o) g += 2;
            else if (p) {
              if ((M = l + d - x) >= 0 && M < f && -1 != c[M])
                if ($ >= (D = s - c[M]))
                  return this.diff_bisectSplit_(t, r, $, w, i);
            }
          }
          for (var j = -_ + v; j <= _ - y; j += 2) {
            for (
              var D,
                M = l + j,
                A =
                  (D =
                    j == -_ || (j != _ && c[M - 1] < c[M + 1])
                      ? c[M + 1]
                      : c[M - 1] + 1) - j;
              D < s && A < o && t.charAt(s - D - 1) == r.charAt(o - A - 1);

            )
              D++, A++;
            if (((c[M] = D), D > s)) y += 2;
            else if (A > o) v += 2;
            else if (!p) {
              if ((b = l + d - j) >= 0 && b < f && -1 != h[b]) {
                var $;
                w = l + ($ = h[b]) - b;
                if ($ >= (D = s - D))
                  return this.diff_bisectSplit_(t, r, $, w, i);
              }
            }
          }
        }
        return [new e.Diff(n, t), new e.Diff(1, r)];
      }),
      (e.prototype.diff_bisectSplit_ = function (t, e, n, r, i) {
        var s = t.substring(0, n),
          o = e.substring(0, r),
          a = t.substring(n),
          l = e.substring(r),
          f = this.diff_main(s, o, !1, i),
          h = this.diff_main(a, l, !1, i);
        return f.concat(h);
      }),
      (e.prototype.diff_linesToChars_ = function (t, e) {
        var n = [],
          r = {};
        function i(t) {
          for (var e = "", i = 0, o = -1, a = n.length; o < t.length - 1; ) {
            -1 == (o = t.indexOf("\n", i)) && (o = t.length - 1);
            var l = t.substring(i, o + 1);
            (r.hasOwnProperty ? r.hasOwnProperty(l) : void 0 !== r[l])
              ? (e += String.fromCharCode(r[l]))
              : (a == s && ((l = t.substring(i)), (o = t.length)),
                (e += String.fromCharCode(a)),
                (r[l] = a),
                (n[a++] = l)),
              (i = o + 1);
          }
          return e;
        }
        n[0] = "";
        var s = 4e4,
          o = i(t);
        return (s = 65535), { chars1: o, chars2: i(e), lineArray: n };
      }),
      (e.prototype.diff_charsToLines_ = function (t, e) {
        for (var n = 0; n < t.length; n++) {
          for (var r = t[n][1], i = [], s = 0; s < r.length; s++)
            i[s] = e[r.charCodeAt(s)];
          t[n][1] = i.join("");
        }
      }),
      (e.prototype.diff_commonPrefix = function (t, e) {
        if (!t || !e || t.charAt(0) != e.charAt(0)) return 0;
        for (var n = 0, r = Math.min(t.length, e.length), i = r, s = 0; n < i; )
          t.substring(s, i) == e.substring(s, i) ? (s = n = i) : (r = i),
            (i = Math.floor((r - n) / 2 + n));
        return i;
      }),
      (e.prototype.diff_commonSuffix = function (t, e) {
        if (!t || !e || t.charAt(t.length - 1) != e.charAt(e.length - 1))
          return 0;
        for (var n = 0, r = Math.min(t.length, e.length), i = r, s = 0; n < i; )
          t.substring(t.length - i, t.length - s) ==
          e.substring(e.length - i, e.length - s)
            ? (s = n = i)
            : (r = i),
            (i = Math.floor((r - n) / 2 + n));
        return i;
      }),
      (e.prototype.diff_commonOverlap_ = function (t, e) {
        var n = t.length,
          r = e.length;
        if (0 == n || 0 == r) return 0;
        n > r ? (t = t.substring(n - r)) : n < r && (e = e.substring(0, n));
        var i = Math.min(n, r);
        if (t == e) return i;
        for (var s = 0, o = 1; ; ) {
          var a = t.substring(i - o),
            l = e.indexOf(a);
          if (-1 == l) return s;
          (o += l),
            (0 != l && t.substring(i - o) != e.substring(0, o)) ||
              ((s = o), o++);
        }
      }),
      (e.prototype.diff_halfMatch_ = function (t, e) {
        if (this.Diff_Timeout <= 0) return null;
        var n = t.length > e.length ? t : e,
          r = t.length > e.length ? e : t;
        if (n.length < 4 || 2 * r.length < n.length) return null;
        var i = this;
        function s(t, e, n) {
          for (
            var r,
              s,
              o,
              a,
              l = t.substring(n, n + Math.floor(t.length / 4)),
              f = -1,
              h = "";
            -1 != (f = e.indexOf(l, f + 1));

          ) {
            var c = i.diff_commonPrefix(t.substring(n), e.substring(f)),
              u = i.diff_commonSuffix(t.substring(0, n), e.substring(0, f));
            h.length < u + c &&
              ((h = e.substring(f - u, f) + e.substring(f, f + c)),
              (r = t.substring(0, n - u)),
              (s = t.substring(n + c)),
              (o = e.substring(0, f - u)),
              (a = e.substring(f + c)));
          }
          return 2 * h.length >= t.length ? [r, s, o, a, h] : null;
        }
        var o,
          a,
          l,
          f,
          h,
          c = s(n, r, Math.ceil(n.length / 4)),
          u = s(n, r, Math.ceil(n.length / 2));
        return c || u
          ? ((o = u ? (c && c[4].length > u[4].length ? c : u) : c),
            t.length > e.length
              ? ((a = o[0]), (l = o[1]), (f = o[2]), (h = o[3]))
              : ((f = o[0]), (h = o[1]), (a = o[2]), (l = o[3])),
            [a, l, f, h, o[4]])
          : null;
      }),
      (e.prototype.diff_cleanupSemantic = function (t) {
        for (
          var r = !1,
            i = [],
            s = 0,
            o = null,
            a = 0,
            l = 0,
            f = 0,
            h = 0,
            c = 0;
          a < t.length;

        )
          0 == t[a][0]
            ? ((i[s++] = a), (l = h), (f = c), (h = 0), (c = 0), (o = t[a][1]))
            : (1 == t[a][0] ? (h += t[a][1].length) : (c += t[a][1].length),
              o &&
                o.length <= Math.max(l, f) &&
                o.length <= Math.max(h, c) &&
                (t.splice(i[s - 1], 0, new e.Diff(n, o)),
                (t[i[s - 1] + 1][0] = 1),
                s--,
                (a = --s > 0 ? i[s - 1] : -1),
                (l = 0),
                (f = 0),
                (h = 0),
                (c = 0),
                (o = null),
                (r = !0))),
            a++;
        for (
          r && this.diff_cleanupMerge(t),
            this.diff_cleanupSemanticLossless(t),
            a = 1;
          a < t.length;

        ) {
          if (t[a - 1][0] == n && 1 == t[a][0]) {
            var u = t[a - 1][1],
              d = t[a][1],
              p = this.diff_commonOverlap_(u, d),
              g = this.diff_commonOverlap_(d, u);
            p >= g
              ? (p >= u.length / 2 || p >= d.length / 2) &&
                (t.splice(a, 0, new e.Diff(0, d.substring(0, p))),
                (t[a - 1][1] = u.substring(0, u.length - p)),
                (t[a + 1][1] = d.substring(p)),
                a++)
              : (g >= u.length / 2 || g >= d.length / 2) &&
                (t.splice(a, 0, new e.Diff(0, u.substring(0, g))),
                (t[a - 1][0] = 1),
                (t[a - 1][1] = d.substring(0, d.length - g)),
                (t[a + 1][0] = n),
                (t[a + 1][1] = u.substring(g)),
                a++),
              a++;
          }
          a++;
        }
      }),
      (e.prototype.diff_cleanupSemanticLossless = function (t) {
        function n(t, n) {
          if (!t || !n) return 6;
          var r = t.charAt(t.length - 1),
            i = n.charAt(0),
            s = r.match(e.nonAlphaNumericRegex_),
            o = i.match(e.nonAlphaNumericRegex_),
            a = s && r.match(e.whitespaceRegex_),
            l = o && i.match(e.whitespaceRegex_),
            f = a && r.match(e.linebreakRegex_),
            h = l && i.match(e.linebreakRegex_),
            c = f && t.match(e.blanklineEndRegex_),
            u = h && n.match(e.blanklineStartRegex_);
          return c || u
            ? 5
            : f || h
            ? 4
            : s && !a && l
            ? 3
            : a || l
            ? 2
            : s || o
            ? 1
            : 0;
        }
        for (var r = 1; r < t.length - 1; ) {
          if (0 == t[r - 1][0] && 0 == t[r + 1][0]) {
            var i = t[r - 1][1],
              s = t[r][1],
              o = t[r + 1][1],
              a = this.diff_commonSuffix(i, s);
            if (a) {
              var l = s.substring(s.length - a);
              (i = i.substring(0, i.length - a)),
                (s = l + s.substring(0, s.length - a)),
                (o = l + o);
            }
            for (
              var f = i, h = s, c = o, u = n(i, s) + n(s, o);
              s.charAt(0) === o.charAt(0);

            ) {
              (i += s.charAt(0)),
                (s = s.substring(1) + o.charAt(0)),
                (o = o.substring(1));
              var d = n(i, s) + n(s, o);
              d >= u && ((u = d), (f = i), (h = s), (c = o));
            }
            t[r - 1][1] != f &&
              (f ? (t[r - 1][1] = f) : (t.splice(r - 1, 1), r--),
              (t[r][1] = h),
              c ? (t[r + 1][1] = c) : (t.splice(r + 1, 1), r--));
          }
          r++;
        }
      }),
      (e.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/),
      (e.whitespaceRegex_ = /\s/),
      (e.linebreakRegex_ = /[\r\n]/),
      (e.blanklineEndRegex_ = /\n\r?\n$/),
      (e.blanklineStartRegex_ = /^\r?\n\r?\n/),
      (e.prototype.diff_cleanupEfficiency = function (t) {
        for (
          var r = !1,
            i = [],
            s = 0,
            o = null,
            a = 0,
            l = !1,
            f = !1,
            h = !1,
            c = !1;
          a < t.length;

        )
          0 == t[a][0]
            ? (t[a][1].length < this.Diff_EditCost && (h || c)
                ? ((i[s++] = a), (l = h), (f = c), (o = t[a][1]))
                : ((s = 0), (o = null)),
              (h = c = !1))
            : (t[a][0] == n ? (c = !0) : (h = !0),
              o &&
                ((l && f && h && c) ||
                  (o.length < this.Diff_EditCost / 2 && l + f + h + c == 3)) &&
                (t.splice(i[s - 1], 0, new e.Diff(n, o)),
                (t[i[s - 1] + 1][0] = 1),
                s--,
                (o = null),
                l && f
                  ? ((h = c = !0), (s = 0))
                  : ((a = --s > 0 ? i[s - 1] : -1), (h = c = !1)),
                (r = !0))),
            a++;
        r && this.diff_cleanupMerge(t);
      }),
      (e.prototype.diff_cleanupMerge = function (t) {
        t.push(new e.Diff(0, ""));
        for (var r, i = 0, s = 0, o = 0, a = "", l = ""; i < t.length; )
          switch (t[i][0]) {
            case 1:
              o++, (l += t[i][1]), i++;
              break;
            case n:
              s++, (a += t[i][1]), i++;
              break;
            case 0:
              s + o > 1
                ? (0 !== s &&
                    0 !== o &&
                    (0 !== (r = this.diff_commonPrefix(l, a)) &&
                      (i - s - o > 0 && 0 == t[i - s - o - 1][0]
                        ? (t[i - s - o - 1][1] += l.substring(0, r))
                        : (t.splice(0, 0, new e.Diff(0, l.substring(0, r))),
                          i++),
                      (l = l.substring(r)),
                      (a = a.substring(r))),
                    0 !== (r = this.diff_commonSuffix(l, a)) &&
                      ((t[i][1] = l.substring(l.length - r) + t[i][1]),
                      (l = l.substring(0, l.length - r)),
                      (a = a.substring(0, a.length - r)))),
                  (i -= s + o),
                  t.splice(i, s + o),
                  a.length && (t.splice(i, 0, new e.Diff(n, a)), i++),
                  l.length && (t.splice(i, 0, new e.Diff(1, l)), i++),
                  i++)
                : 0 !== i && 0 == t[i - 1][0]
                ? ((t[i - 1][1] += t[i][1]), t.splice(i, 1))
                : i++,
                (o = 0),
                (s = 0),
                (a = ""),
                (l = "");
          }
        "" === t[t.length - 1][1] && t.pop();
        var f = !1;
        for (i = 1; i < t.length - 1; )
          0 == t[i - 1][0] &&
            0 == t[i + 1][0] &&
            (t[i][1].substring(t[i][1].length - t[i - 1][1].length) ==
            t[i - 1][1]
              ? ((t[i][1] =
                  t[i - 1][1] +
                  t[i][1].substring(0, t[i][1].length - t[i - 1][1].length)),
                (t[i + 1][1] = t[i - 1][1] + t[i + 1][1]),
                t.splice(i - 1, 1),
                (f = !0))
              : t[i][1].substring(0, t[i + 1][1].length) == t[i + 1][1] &&
                ((t[i - 1][1] += t[i + 1][1]),
                (t[i][1] = t[i][1].substring(t[i + 1][1].length) + t[i + 1][1]),
                t.splice(i + 1, 1),
                (f = !0))),
            i++;
        f && this.diff_cleanupMerge(t);
      }),
      (e.prototype.diff_xIndex = function (t, e) {
        var r,
          i = 0,
          s = 0,
          o = 0,
          a = 0;
        for (
          r = 0;
          r < t.length &&
          (1 !== t[r][0] && (i += t[r][1].length),
          t[r][0] !== n && (s += t[r][1].length),
          !(i > e));
          r++
        )
          (o = i), (a = s);
        return t.length != r && t[r][0] === n ? a : a + (e - o);
      }),
      (e.prototype.diff_prettyHtml = function (t) {
        for (
          var e = [], r = /&/g, i = /</g, s = />/g, o = /\n/g, a = 0;
          a < t.length;
          a++
        ) {
          var l = t[a][0],
            f = t[a][1]
              .replace(r, "&amp;")
              .replace(i, "&lt;")
              .replace(s, "&gt;")
              .replace(o, "&para;<br>");
          switch (l) {
            case 1:
              e[a] = '<ins style="background:#e6ffe6;">' + f + "</ins>";
              break;
            case n:
              e[a] = '<del style="background:#ffe6e6;">' + f + "</del>";
              break;
            case 0:
              e[a] = "<span>" + f + "</span>";
          }
        }
        return e.join("");
      }),
      (e.prototype.diff_text1 = function (t) {
        for (var e = [], n = 0; n < t.length; n++)
          1 !== t[n][0] && (e[n] = t[n][1]);
        return e.join("");
      }),
      (e.prototype.diff_text2 = function (t) {
        for (var e = [], r = 0; r < t.length; r++)
          t[r][0] !== n && (e[r] = t[r][1]);
        return e.join("");
      }),
      (e.prototype.diff_levenshtein = function (t) {
        for (var e = 0, r = 0, i = 0, s = 0; s < t.length; s++) {
          var o = t[s][0],
            a = t[s][1];
          switch (o) {
            case 1:
              r += a.length;
              break;
            case n:
              i += a.length;
              break;
            case 0:
              (e += Math.max(r, i)), (r = 0), (i = 0);
          }
        }
        return (e += Math.max(r, i));
      }),
      (e.prototype.diff_toDelta = function (t) {
        for (var e = [], r = 0; r < t.length; r++)
          switch (t[r][0]) {
            case 1:
              e[r] = "+" + encodeURI(t[r][1]);
              break;
            case n:
              e[r] = "-" + t[r][1].length;
              break;
            case 0:
              e[r] = "=" + t[r][1].length;
          }
        return e.join("\t").replace(/%20/g, " ");
      }),
      (e.prototype.diff_fromDelta = function (t, r) {
        for (
          var i = [], s = 0, o = 0, a = r.split(/\t/g), l = 0;
          l < a.length;
          l++
        ) {
          var f = a[l].substring(1);
          switch (a[l].charAt(0)) {
            case "+":
              try {
                i[s++] = new e.Diff(1, decodeURI(f));
              } catch (t) {
                throw new Error("Illegal escape in diff_fromDelta: " + f);
              }
              break;
            case "-":
            case "=":
              var h = parseInt(f, 10);
              if (isNaN(h) || h < 0)
                throw new Error("Invalid number in diff_fromDelta: " + f);
              var c = t.substring(o, (o += h));
              "=" == a[l].charAt(0)
                ? (i[s++] = new e.Diff(0, c))
                : (i[s++] = new e.Diff(n, c));
              break;
            default:
              if (a[l])
                throw new Error(
                  "Invalid diff operation in diff_fromDelta: " + a[l]
                );
          }
        }
        if (o != t.length)
          throw new Error(
            "Delta length (" +
              o +
              ") does not equal source text length (" +
              t.length +
              ")."
          );
        return i;
      }),
      (e.prototype.match_main = function (t, e, n) {
        if (null == t || null == e || null == n)
          throw new Error("Null input. (match_main)");
        return (
          (n = Math.max(0, Math.min(n, t.length))),
          t == e
            ? 0
            : t.length
            ? t.substring(n, n + e.length) == e
              ? n
              : this.match_bitap_(t, e, n)
            : -1
        );
      }),
      (e.prototype.match_bitap_ = function (t, e, n) {
        if (e.length > this.Match_MaxBits)
          throw new Error("Pattern too long for this browser.");
        var r = this.match_alphabet_(e),
          i = this;
        function s(t, r) {
          var s = t / e.length,
            o = Math.abs(n - r);
          return i.Match_Distance ? s + o / i.Match_Distance : o ? 1 : s;
        }
        var o = this.Match_Threshold,
          a = t.indexOf(e, n);
        -1 != a &&
          ((o = Math.min(s(0, a), o)),
          -1 != (a = t.lastIndexOf(e, n + e.length)) &&
            (o = Math.min(s(0, a), o)));
        var l,
          f,
          h = 1 << (e.length - 1);
        a = -1;
        for (var c, u = e.length + t.length, d = 0; d < e.length; d++) {
          for (l = 0, f = u; l < f; )
            s(d, n + f) <= o ? (l = f) : (u = f),
              (f = Math.floor((u - l) / 2 + l));
          u = f;
          var p = Math.max(1, n - f + 1),
            g = Math.min(n + f, t.length) + e.length,
            m = Array(g + 2);
          m[g + 1] = (1 << d) - 1;
          for (var v = g; v >= p; v--) {
            var y = r[t.charAt(v - 1)];
            if (
              ((m[v] =
                0 === d
                  ? ((m[v + 1] << 1) | 1) & y
                  : (((m[v + 1] << 1) | 1) & y) |
                    ((c[v + 1] | c[v]) << 1) |
                    1 |
                    c[v + 1]),
              m[v] & h)
            ) {
              var _ = s(d, v - 1);
              if (_ <= o) {
                if (((o = _), !((a = v - 1) > n))) break;
                p = Math.max(1, 2 * n - a);
              }
            }
          }
          if (s(d + 1, n) > o) break;
          c = m;
        }
        return a;
      }),
      (e.prototype.match_alphabet_ = function (t) {
        for (var e = {}, n = 0; n < t.length; n++) e[t.charAt(n)] = 0;
        for (n = 0; n < t.length; n++)
          e[t.charAt(n)] |= 1 << (t.length - n - 1);
        return e;
      }),
      (e.prototype.patch_addContext_ = function (t, n) {
        if (0 != n.length) {
          if (null === t.start2) throw Error("patch not initialized");
          for (
            var r = n.substring(t.start2, t.start2 + t.length1), i = 0;
            n.indexOf(r) != n.lastIndexOf(r) &&
            r.length <
              this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin;

          )
            (i += this.Patch_Margin),
              (r = n.substring(t.start2 - i, t.start2 + t.length1 + i));
          i += this.Patch_Margin;
          var s = n.substring(t.start2 - i, t.start2);
          s && t.diffs.unshift(new e.Diff(0, s));
          var o = n.substring(t.start2 + t.length1, t.start2 + t.length1 + i);
          o && t.diffs.push(new e.Diff(0, o)),
            (t.start1 -= s.length),
            (t.start2 -= s.length),
            (t.length1 += s.length + o.length),
            (t.length2 += s.length + o.length);
        }
      }),
      (e.prototype.patch_make = function (t, r, i) {
        var s, o;
        if ("string" == typeof t && "string" == typeof r && void 0 === i)
          (s = t),
            (o = this.diff_main(s, r, !0)).length > 2 &&
              (this.diff_cleanupSemantic(o), this.diff_cleanupEfficiency(o));
        else if (t && "object" == typeof t && void 0 === r && void 0 === i)
          (o = t), (s = this.diff_text1(o));
        else if (
          "string" == typeof t &&
          r &&
          "object" == typeof r &&
          void 0 === i
        )
          (s = t), (o = r);
        else {
          if (
            "string" != typeof t ||
            "string" != typeof r ||
            !i ||
            "object" != typeof i
          )
            throw new Error("Unknown call format to patch_make.");
          (s = t), (o = i);
        }
        if (0 === o.length) return [];
        for (
          var a = [],
            l = new e.patch_obj(),
            f = 0,
            h = 0,
            c = 0,
            u = s,
            d = s,
            p = 0;
          p < o.length;
          p++
        ) {
          var g = o[p][0],
            m = o[p][1];
          switch ((f || 0 === g || ((l.start1 = h), (l.start2 = c)), g)) {
            case 1:
              (l.diffs[f++] = o[p]),
                (l.length2 += m.length),
                (d = d.substring(0, c) + m + d.substring(c));
              break;
            case n:
              (l.length1 += m.length),
                (l.diffs[f++] = o[p]),
                (d = d.substring(0, c) + d.substring(c + m.length));
              break;
            case 0:
              m.length <= 2 * this.Patch_Margin && f && o.length != p + 1
                ? ((l.diffs[f++] = o[p]),
                  (l.length1 += m.length),
                  (l.length2 += m.length))
                : m.length >= 2 * this.Patch_Margin &&
                  f &&
                  (this.patch_addContext_(l, u),
                  a.push(l),
                  (l = new e.patch_obj()),
                  (f = 0),
                  (u = d),
                  (h = c));
          }
          1 !== g && (h += m.length), g !== n && (c += m.length);
        }
        return f && (this.patch_addContext_(l, u), a.push(l)), a;
      }),
      (e.prototype.patch_deepCopy = function (t) {
        for (var n = [], r = 0; r < t.length; r++) {
          var i = t[r],
            s = new e.patch_obj();
          s.diffs = [];
          for (var o = 0; o < i.diffs.length; o++)
            s.diffs[o] = new e.Diff(i.diffs[o][0], i.diffs[o][1]);
          (s.start1 = i.start1),
            (s.start2 = i.start2),
            (s.length1 = i.length1),
            (s.length2 = i.length2),
            (n[r] = s);
        }
        return n;
      }),
      (e.prototype.patch_apply = function (t, e) {
        if (0 == t.length) return [e, []];
        t = this.patch_deepCopy(t);
        var r = this.patch_addPadding(t);
        (e = r + e + r), this.patch_splitMax(t);
        for (var i = 0, s = [], o = 0; o < t.length; o++) {
          var a,
            l,
            f = t[o].start2 + i,
            h = this.diff_text1(t[o].diffs),
            c = -1;
          if (
            (h.length > this.Match_MaxBits
              ? -1 !=
                  (a = this.match_main(
                    e,
                    h.substring(0, this.Match_MaxBits),
                    f
                  )) &&
                (-1 ==
                  (c = this.match_main(
                    e,
                    h.substring(h.length - this.Match_MaxBits),
                    f + h.length - this.Match_MaxBits
                  )) ||
                  a >= c) &&
                (a = -1)
              : (a = this.match_main(e, h, f)),
            -1 == a)
          )
            (s[o] = !1), (i -= t[o].length2 - t[o].length1);
          else if (
            ((s[o] = !0),
            (i = a - f),
            h ==
              (l =
                -1 == c
                  ? e.substring(a, a + h.length)
                  : e.substring(a, c + this.Match_MaxBits)))
          )
            e =
              e.substring(0, a) +
              this.diff_text2(t[o].diffs) +
              e.substring(a + h.length);
          else {
            var u = this.diff_main(h, l, !1);
            if (
              h.length > this.Match_MaxBits &&
              this.diff_levenshtein(u) / h.length > this.Patch_DeleteThreshold
            )
              s[o] = !1;
            else {
              this.diff_cleanupSemanticLossless(u);
              for (var d, p = 0, g = 0; g < t[o].diffs.length; g++) {
                var m = t[o].diffs[g];
                0 !== m[0] && (d = this.diff_xIndex(u, p)),
                  1 === m[0]
                    ? (e = e.substring(0, a + d) + m[1] + e.substring(a + d))
                    : m[0] === n &&
                      (e =
                        e.substring(0, a + d) +
                        e.substring(a + this.diff_xIndex(u, p + m[1].length))),
                  m[0] !== n && (p += m[1].length);
              }
            }
          }
        }
        return [(e = e.substring(r.length, e.length - r.length)), s];
      }),
      (e.prototype.patch_addPadding = function (t) {
        for (var n = this.Patch_Margin, r = "", i = 1; i <= n; i++)
          r += String.fromCharCode(i);
        for (i = 0; i < t.length; i++) (t[i].start1 += n), (t[i].start2 += n);
        var s = t[0],
          o = s.diffs;
        if (0 == o.length || 0 != o[0][0])
          o.unshift(new e.Diff(0, r)),
            (s.start1 -= n),
            (s.start2 -= n),
            (s.length1 += n),
            (s.length2 += n);
        else if (n > o[0][1].length) {
          var a = n - o[0][1].length;
          (o[0][1] = r.substring(o[0][1].length) + o[0][1]),
            (s.start1 -= a),
            (s.start2 -= a),
            (s.length1 += a),
            (s.length2 += a);
        }
        if (
          0 == (o = (s = t[t.length - 1]).diffs).length ||
          0 != o[o.length - 1][0]
        )
          o.push(new e.Diff(0, r)), (s.length1 += n), (s.length2 += n);
        else if (n > o[o.length - 1][1].length) {
          a = n - o[o.length - 1][1].length;
          (o[o.length - 1][1] += r.substring(0, a)),
            (s.length1 += a),
            (s.length2 += a);
        }
        return r;
      }),
      (e.prototype.patch_splitMax = function (t) {
        for (var r = this.Match_MaxBits, i = 0; i < t.length; i++)
          if (!(t[i].length1 <= r)) {
            var s = t[i];
            t.splice(i--, 1);
            for (
              var o = s.start1, a = s.start2, l = "";
              0 !== s.diffs.length;

            ) {
              var f = new e.patch_obj(),
                h = !0;
              for (
                f.start1 = o - l.length,
                  f.start2 = a - l.length,
                  "" !== l &&
                    ((f.length1 = f.length2 = l.length),
                    f.diffs.push(new e.Diff(0, l)));
                0 !== s.diffs.length && f.length1 < r - this.Patch_Margin;

              ) {
                var c = s.diffs[0][0],
                  u = s.diffs[0][1];
                1 === c
                  ? ((f.length2 += u.length),
                    (a += u.length),
                    f.diffs.push(s.diffs.shift()),
                    (h = !1))
                  : c === n &&
                    1 == f.diffs.length &&
                    0 == f.diffs[0][0] &&
                    u.length > 2 * r
                  ? ((f.length1 += u.length),
                    (o += u.length),
                    (h = !1),
                    f.diffs.push(new e.Diff(c, u)),
                    s.diffs.shift())
                  : ((u = u.substring(0, r - f.length1 - this.Patch_Margin)),
                    (f.length1 += u.length),
                    (o += u.length),
                    0 === c
                      ? ((f.length2 += u.length), (a += u.length))
                      : (h = !1),
                    f.diffs.push(new e.Diff(c, u)),
                    u == s.diffs[0][1]
                      ? s.diffs.shift()
                      : (s.diffs[0][1] = s.diffs[0][1].substring(u.length)));
              }
              l = (l = this.diff_text2(f.diffs)).substring(
                l.length - this.Patch_Margin
              );
              var d = this.diff_text1(s.diffs).substring(0, this.Patch_Margin);
              "" !== d &&
                ((f.length1 += d.length),
                (f.length2 += d.length),
                0 !== f.diffs.length && 0 === f.diffs[f.diffs.length - 1][0]
                  ? (f.diffs[f.diffs.length - 1][1] += d)
                  : f.diffs.push(new e.Diff(0, d))),
                h || t.splice(++i, 0, f);
            }
          }
      }),
      (e.prototype.patch_toText = function (t) {
        for (var e = [], n = 0; n < t.length; n++) e[n] = t[n];
        return e.join("");
      }),
      (e.prototype.patch_fromText = function (t) {
        var r = [];
        if (!t) return r;
        for (
          var i = t.split("\n"),
            s = 0,
            o = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
          s < i.length;

        ) {
          var a = i[s].match(o);
          if (!a) throw new Error("Invalid patch string: " + i[s]);
          var l = new e.patch_obj();
          for (
            r.push(l),
              l.start1 = parseInt(a[1], 10),
              "" === a[2]
                ? (l.start1--, (l.length1 = 1))
                : "0" == a[2]
                ? (l.length1 = 0)
                : (l.start1--, (l.length1 = parseInt(a[2], 10))),
              l.start2 = parseInt(a[3], 10),
              "" === a[4]
                ? (l.start2--, (l.length2 = 1))
                : "0" == a[4]
                ? (l.length2 = 0)
                : (l.start2--, (l.length2 = parseInt(a[4], 10))),
              s++;
            s < i.length;

          ) {
            var f = i[s].charAt(0);
            try {
              var h = decodeURI(i[s].substring(1));
            } catch (t) {
              throw new Error("Illegal escape in patch_fromText: " + h);
            }
            if ("-" == f) l.diffs.push(new e.Diff(n, h));
            else if ("+" == f) l.diffs.push(new e.Diff(1, h));
            else if (" " == f) l.diffs.push(new e.Diff(0, h));
            else {
              if ("@" == f) break;
              if ("" !== f)
                throw new Error('Invalid patch mode "' + f + '" in: ' + h);
            }
            s++;
          }
        }
        return r;
      }),
      ((e.patch_obj = function () {
        (this.diffs = []),
          (this.start1 = null),
          (this.start2 = null),
          (this.length1 = 0),
          (this.length2 = 0);
      }).prototype.toString = function () {
        for (
          var t,
            e = [
              "@@ -" +
                (0 === this.length1
                  ? this.start1 + ",0"
                  : 1 == this.length1
                  ? this.start1 + 1
                  : this.start1 + 1 + "," + this.length1) +
                " +" +
                (0 === this.length2
                  ? this.start2 + ",0"
                  : 1 == this.length2
                  ? this.start2 + 1
                  : this.start2 + 1 + "," + this.length2) +
                " @@\n",
            ],
            r = 0;
          r < this.diffs.length;
          r++
        ) {
          switch (this.diffs[r][0]) {
            case 1:
              t = "+";
              break;
            case n:
              t = "-";
              break;
            case 0:
              t = " ";
          }
          e[r + 1] = t + encodeURI(this.diffs[r][1]) + "\n";
        }
        return e.join("").replace(/%20/g, " ");
      }),
      (t.exports = e),
      (t.exports.diff_match_patch = e),
      (t.exports.DIFF_DELETE = n),
      (t.exports.DIFF_INSERT = 1),
      (t.exports.DIFF_EQUAL = 0);
  })(N);
  var P = T(N.exports);
  let I = null;
  const S = function (t) {
      if (!I) {
        let e;
        if ("undefined" != typeof diff_match_patch)
          e =
            "function" == typeof diff_match_patch
              ? new diff_match_patch()
              : new diff_match_patch.diff_match_patch();
        else if (P)
          try {
            e = P && new P();
          } catch (t) {
            e = null;
          }
        if (!e) {
          if (!t) return null;
          const e = new Error("text diff_match_patch library not found");
          throw ((e.diff_match_patch_not_found = !0), e);
        }
        I = {
          diff: function (t, n) {
            return e.patch_toText(e.patch_make(t, n));
          },
          patch: function (t, n) {
            const r = e.patch_apply(e.patch_fromText(n), t);
            for (let t = 0; t < r[1].length; t++)
              if (!r[1][t]) {
                new Error("text patch failed").textPatchFailed = !0;
              }
            return r[0];
          },
        };
      }
      return I;
    },
    B = function (t) {
      if ("string" !== t.leftType) return;
      const e =
        (t.options && t.options.textDiff && t.options.textDiff.minLength) || 60;
      if (t.left.length < e || t.right.length < e)
        return void t.setResult([t.left, t.right]).exit();
      const n = S();
      if (!n) return void t.setResult([t.left, t.right]).exit();
      const r = n.diff;
      t.setResult([r(t.left, t.right), 0, 2]).exit();
    };
  B.filterName = "texts";
  const L = function (t) {
    if (t.nested) return;
    if (2 !== t.delta[2]) return;
    const e = S(!0).patch;
    t.setResult(e(t.left, t.delta[0])).exit();
  };
  L.filterName = "texts";
  const F = function (t) {
      let e,
        n,
        r,
        i,
        s = null;
      const o = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
      let a;
      const l = t.split("\n");
      for (e = 0, n = l.length; e < n; e++) {
        r = l[e];
        const t = r.slice(0, 1);
        "@" === t
          ? ((s = o.exec(r)),
            (a = e),
            (l[a] =
              "@@ -" + s[3] + "," + s[4] + " +" + s[1] + "," + s[2] + " @@"))
          : "+" === t
          ? ((l[e] = "-" + l[e].slice(1)),
            "+" === l[e - 1].slice(0, 1) &&
              ((i = l[e]), (l[e] = l[e - 1]), (l[e - 1] = i)))
          : "-" === t && (l[e] = "+" + l[e].slice(1));
      }
      return l.join("\n");
    },
    V = function (t) {
      t.nested ||
        (2 === t.delta[2] && t.setResult([F(t.delta[0]), 0, 2]).exit());
    };
  V.filterName = "texts";
  class q {
    constructor(t) {
      (this.processor = new n(t)),
        this.processor.pipe(
          new r("diff").append(p, c, O, B, g, M).shouldHaveResult()
        ),
        this.processor.pipe(
          new r("patch").append(v, R, u, L, m, $).shouldHaveResult()
        ),
        this.processor.pipe(
          new r("reverse").append(_, k, d, V, y, C).shouldHaveResult()
        );
    }
    options() {
      return this.processor.options(...arguments);
    }
    diff(t, e) {
      return this.processor.process(new a(t, e));
    }
    patch(t, e) {
      return this.processor.process(new l(t, e));
    }
    reverse(t) {
      return this.processor.process(new f(t));
    }
    unpatch(t, e) {
      return this.patch(t, this.reverse(e));
    }
    clone(t) {
      return o(t);
    }
  }
  const U =
      "function" == typeof Array.isArray
        ? Array.isArray
        : (t) => t instanceof Array,
    z =
      "function" == typeof Object.keys
        ? (t) => Object.keys(t)
        : (t) => {
            const e = [];
            for (const n in t)
              Object.prototype.hasOwnProperty.call(t, n) && e.push(n);
            return e;
          },
    H = (t) =>
      "_t" === t
        ? -1
        : "_" === t.substr(0, 1)
        ? parseInt(t.slice(1), 10)
        : parseInt(t, 10) + 0.1,
    Q = (t, e) => H(t) - H(e);
  class J {
    format(t, e) {
      const n = {};
      return this.prepareContext(n), this.recurse(n, t, e), this.finalize(n);
    }
    prepareContext(t) {
      (t.buffer = []),
        (t.out = function () {
          this.buffer.push(...arguments);
        });
    }
    typeFormattterNotFound(t, e) {
      throw new Error(`cannot format delta type: ${e}`);
    }
    typeFormattterErrorFormatter(t, e) {
      return e.toString();
    }
    finalize(t) {
      let { buffer: e } = t;
      if (U(e)) return e.join("");
    }
    recurse(t, e, n, r, i, s, o) {
      const a = e && s ? s.value : n;
      if (void 0 === e && void 0 === r) return;
      const l = this.getDeltaType(e, s),
        f = "node" === l ? ("a" === e._t ? "array" : "object") : "";
      let h;
      void 0 !== r ? this.nodeBegin(t, r, i, l, f, o) : this.rootBegin(t, l, f);
      try {
        (h = this[`format_${l}`] || this.typeFormattterNotFound(t, l)),
          h.call(this, t, e, a, r, i, s);
      } catch (n) {
        this.typeFormattterErrorFormatter(t, n, e, a, r, i, s),
          "undefined" != typeof console &&
            console.error &&
            console.error(n.stack);
      }
      void 0 !== r ? this.nodeEnd(t, r, i, l, f, o) : this.rootEnd(t, l, f);
    }
    formatDeltaChildren(t, e, n) {
      const r = this;
      this.forEachDeltaKey(e, n, (i, s, o, a) => {
        r.recurse(t, e[i], n ? n[s] : void 0, i, s, o, a);
      });
    }
    forEachDeltaKey(t, e, n) {
      const r = z(t),
        i = "a" === t._t,
        s = {};
      let o;
      if (void 0 !== e)
        for (o in e)
          Object.prototype.hasOwnProperty.call(e, o) &&
            (void 0 !== t[o] || (i && void 0 !== t[`_${o}`]) || r.push(o));
      for (o in t)
        if (Object.prototype.hasOwnProperty.call(t, o)) {
          const n = t[o];
          U(n) &&
            3 === n[2] &&
            ((s[n[1].toString()] = {
              key: o,
              value: e && e[parseInt(o.substr(1))],
            }),
            !1 !== this.includeMoveDestinations &&
              void 0 === e &&
              void 0 === t[n[1]] &&
              r.push(n[1].toString()));
        }
      i ? r.sort(Q) : r.sort();
      for (let t = 0, e = r.length; t < e; t++) {
        const o = r[t];
        if (i && "_t" === o) continue;
        const l = i
            ? "number" == typeof o
              ? o
              : parseInt("_" === (a = o).substr(0, 1) ? a.slice(1) : a, 10)
            : o,
          f = t === e - 1;
        n(o, l, s[l], f);
      }
      var a;
    }
    getDeltaType(t, e) {
      if (void 0 === t) return void 0 !== e ? "movedestination" : "unchanged";
      if (U(t)) {
        if (1 === t.length) return "added";
        if (2 === t.length) return "modified";
        if (3 === t.length && 0 === t[2]) return "deleted";
        if (3 === t.length && 2 === t[2]) return "textdiff";
        if (3 === t.length && 3 === t[2]) return "moved";
      } else if ("object" == typeof t) return "node";
      return "unknown";
    }
    parseTextDiff(t) {
      const e = [],
        n = t.split("\n@@ ");
      for (let t = 0, r = n.length; t < r; t++) {
        const r = n[t],
          i = { pieces: [] },
          s = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(r).slice(1);
        i.location = { line: s[0], chr: s[1] };
        const o = r.split("\n").slice(1);
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t];
          if (!e.length) continue;
          const n = { type: "context" };
          "+" === e.substr(0, 1)
            ? (n.type = "added")
            : "-" === e.substr(0, 1) && (n.type = "deleted"),
            (n.text = e.slice(1)),
            i.pieces.push(n);
        }
        e.push(i);
      }
      return e;
    }
  }
  var K = Object.freeze({ __proto__: null, default: J });
  class Z extends J {
    typeFormattterErrorFormatter(t, e) {
      t.out(`<pre class="jsondiffpatch-error">${e}</pre>`);
    }
    formatValue(t, e) {
      t.out(`<pre>${W(JSON.stringify(e, null, 2))}</pre>`);
    }
    formatTextDiffString(t, e) {
      const n = this.parseTextDiff(e);
      t.out('<ul class="jsondiffpatch-textdiff">');
      for (let e = 0, r = n.length; e < r; e++) {
        const r = n[e];
        t.out(
          `<li><div class="jsondiffpatch-textdiff-location"><span class="jsondiffpatch-textdiff-line-number">${r.location.line}</span><span class="jsondiffpatch-textdiff-char">${r.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`
        );
        const i = r.pieces;
        for (let e = 0, n = i.length; e < n; e++) {
          const n = i[e];
          t.out(
            `<span class="jsondiffpatch-textdiff-${n.type}">${W(
              decodeURI(n.text)
            )}</span>`
          );
        }
        t.out("</div></li>");
      }
      t.out("</ul>");
    }
    rootBegin(t, e, n) {
      const r = `jsondiffpatch-${e}${
        n ? ` jsondiffpatch-child-node-type-${n}` : ""
      }`;
      t.out(`<div class="jsondiffpatch-delta ${r}">`);
    }
    rootEnd(t) {
      t.out(
        "</div>" +
          (t.hasArrows
            ? `<script type="text/javascript">setTimeout(${X.toString()},10);<\/script>`
            : "")
      );
    }
    nodeBegin(t, e, n, r, i) {
      const s = `jsondiffpatch-${r}${
        i ? ` jsondiffpatch-child-node-type-${i}` : ""
      }`;
      t.out(
        `<li class="${s}" data-key="${n}"><div class="jsondiffpatch-property-name">${n}</div>`
      );
    }
    nodeEnd(t) {
      t.out("</li>");
    }
    format_unchanged(t, e, n) {
      void 0 !== n &&
        (t.out('<div class="jsondiffpatch-value">'),
        this.formatValue(t, n),
        t.out("</div>"));
    }
    format_movedestination(t, e, n) {
      void 0 !== n &&
        (t.out('<div class="jsondiffpatch-value">'),
        this.formatValue(t, n),
        t.out("</div>"));
    }
    format_node(t, e, n) {
      const r = "a" === e._t ? "array" : "object";
      t.out(`<ul class="jsondiffpatch-node jsondiffpatch-node-type-${r}">`),
        this.formatDeltaChildren(t, e, n),
        t.out("</ul>");
    }
    format_added(t, e) {
      t.out('<div class="jsondiffpatch-value">'),
        this.formatValue(t, e[0]),
        t.out("</div>");
    }
    format_modified(t, e) {
      t.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">'),
        this.formatValue(t, e[0]),
        t.out(
          '</div><div class="jsondiffpatch-value jsondiffpatch-right-value">'
        ),
        this.formatValue(t, e[1]),
        t.out("</div>");
    }
    format_deleted(t, e) {
      t.out('<div class="jsondiffpatch-value">'),
        this.formatValue(t, e[0]),
        t.out("</div>");
    }
    format_moved(t, e) {
      t.out('<div class="jsondiffpatch-value">'),
        this.formatValue(t, e[0]),
        t.out(
          `</div><div class="jsondiffpatch-moved-destination">${e[1]}</div>`
        ),
        t.out(
          '<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">\n          <svg width="30" height="60" style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>'
        ),
        (t.hasArrows = !0);
    }
    format_textdiff(t, e) {
      t.out('<div class="jsondiffpatch-value">'),
        this.formatTextDiffString(t, e[0]),
        t.out("</div>");
    }
  }
  function W(t) {
    let e = t;
    const n = [
      [/&/g, "&amp;"],
      [/</g, "&lt;"],
      [/>/g, "&gt;"],
      [/'/g, "&apos;"],
      [/"/g, "&quot;"],
    ];
    for (let t = 0; t < n.length; t++) e = e.replace(n[t][0], n[t][1]);
    return e;
  }
  const X = function (t) {
      const e = t || document;
      ((t, e, n) => {
        const r = t.querySelectorAll(e);
        for (let t = 0, e = r.length; t < e; t++) n(r[t]);
      })(e, ".jsondiffpatch-arrow", (t) => {
        let { parentNode: e, children: n, style: r } = t;
        const i = e,
          s = n[0],
          o = s.children[1];
        s.style.display = "none";
        const a = ((t) => {
          let { textContent: e, innerText: n } = t;
          return e || n;
        })(i.querySelector(".jsondiffpatch-moved-destination"));
        let l;
        if (
          (((t, e) => {
            let { children: n } = t;
            for (let t = 0, r = n.length; t < r; t++) e(n[t], t);
          })(i.parentNode, (t) => {
            t.getAttribute("data-key") === a && (l = t);
          }),
          l)
        )
          try {
            const t = l.offsetTop - i.offsetTop;
            s.setAttribute("height", Math.abs(t) + 6),
              (r.top = `${-8 + (t > 0 ? 0 : t)}px`);
            const e =
              t > 0
                ? `M30,0 Q-10,${Math.round(t / 2)} 26,${t - 4}`
                : `M30,${-t} Q-10,${Math.round(-t / 2)} 26,4`;
            o.setAttribute("d", e), (s.style.display = "");
          } catch (t) {}
      });
    },
    G = (t, e, n) => {
      const r = e || document.body,
        i = "jsondiffpatch-unchanged-",
        s = {
          showing: `${i}showing`,
          hiding: `${i}hiding`,
          visible: `${i}visible`,
          hidden: `${i}hidden`,
        },
        o = r.classList;
      if (!o) return;
      if (!n)
        return (
          o.remove(s.showing),
          o.remove(s.hiding),
          o.remove(s.visible),
          o.remove(s.hidden),
          void (!1 === t && o.add(s.hidden))
        );
      !1 === t
        ? (o.remove(s.showing),
          o.add(s.visible),
          setTimeout(() => {
            o.add(s.hiding);
          }, 10))
        : (o.remove(s.hiding), o.add(s.showing), o.remove(s.hidden));
      const a = setInterval(() => {
        X(r);
      }, 100);
      setTimeout(() => {
        o.remove(s.showing),
          o.remove(s.hiding),
          !1 === t
            ? (o.add(s.hidden), o.remove(s.visible))
            : (o.add(s.visible), o.remove(s.hidden)),
          setTimeout(() => {
            o.remove(s.visible), clearInterval(a);
          }, n + 400);
      }, n);
    };
  let Y;
  var tt = Object.freeze({
    __proto__: null,
    default: Z,
    format: function (t, e) {
      return Y || (Y = new Z()), Y.format(t, e);
    },
    hideUnchanged: (t, e) => G(!1, t, e),
    showUnchanged: G,
  });
  class et extends J {
    constructor() {
      super(), (this.includeMoveDestinations = !1);
    }
    prepareContext(t) {
      super.prepareContext(t),
        (t.indent = function (t) {
          (this.indentLevel = (this.indentLevel || 0) + (void 0 === t ? 1 : t)),
            (this.indentPad = new Array(this.indentLevel + 1).join(
              "&nbsp;&nbsp;"
            ));
        }),
        (t.row = (e, n) => {
          t.out(
            '<tr><td style="white-space: nowrap;"><pre class="jsondiffpatch-annotated-indent" style="display: inline-block">'
          ),
            t.out(t.indentPad),
            t.out('</pre><pre style="display: inline-block">'),
            t.out(e),
            t.out('</pre></td><td class="jsondiffpatch-delta-note"><div>'),
            t.out(n),
            t.out("</div></td></tr>");
        });
    }
    typeFormattterErrorFormatter(t, e) {
      t.row("", `<pre class="jsondiffpatch-error">${e}</pre>`);
    }
    formatTextDiffString(t, e) {
      const n = this.parseTextDiff(e);
      t.out('<ul class="jsondiffpatch-textdiff">');
      for (let e = 0, r = n.length; e < r; e++) {
        const r = n[e];
        t.out(
          `<li><div class="jsondiffpatch-textdiff-location"><span class="jsondiffpatch-textdiff-line-number">${r.location.line}</span><span class="jsondiffpatch-textdiff-char">${r.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`
        );
        const i = r.pieces;
        for (let e = 0, n = i.length; e < n; e++) {
          const n = i[e];
          t.out(
            `<span class="jsondiffpatch-textdiff-${n.type}">${n.text}</span>`
          );
        }
        t.out("</div></li>");
      }
      t.out("</ul>");
    }
    rootBegin(t, e, n) {
      t.out('<table class="jsondiffpatch-annotated-delta">'),
        "node" === e && (t.row("{"), t.indent()),
        "array" === n &&
          t.row(
            '"_t": "a",',
            "Array delta (member names indicate array indices)"
          );
    }
    rootEnd(t, e) {
      "node" === e && (t.indent(-1), t.row("}")), t.out("</table>");
    }
    nodeBegin(t, e, n, r, i) {
      t.row(`&quot;${e}&quot;: {`),
        "node" === r && t.indent(),
        "array" === i &&
          t.row(
            '"_t": "a",',
            "Array delta (member names indicate array indices)"
          );
    }
    nodeEnd(t, e, n, r, i, s) {
      "node" === r && t.indent(-1), t.row("}" + (s ? "" : ","));
    }
    format_unchanged() {}
    format_movedestination() {}
    format_node(t, e, n) {
      this.formatDeltaChildren(t, e, n);
    }
  }
  const nt = (t) => `<pre style="display:inline-block">&quot;${t}&quot;</pre>`,
    rt = {
      added(t, e, n, r) {
        const i = " <pre>([newValue])</pre>";
        return void 0 === r
          ? `new value${i}`
          : "number" == typeof r
          ? `insert at index ${r}${i}`
          : `add property ${nt(r)}${i}`;
      },
      modified(t, e, n, r) {
        const i = " <pre>([previousValue, newValue])</pre>";
        return void 0 === r
          ? `modify value${i}`
          : "number" == typeof r
          ? `modify at index ${r}${i}`
          : `modify property ${nt(r)}${i}`;
      },
      deleted(t, e, n, r) {
        const i = " <pre>([previousValue, 0, 0])</pre>";
        return void 0 === r
          ? `delete value${i}`
          : "number" == typeof r
          ? `remove index ${r}${i}`
          : `delete property ${nt(r)}${i}`;
      },
      moved: (t, e, n, r) =>
        `move from <span title="(position to remove at original state)">index ${r}</span> to <span title="(position to insert at final state)">index ${t[1]}</span>`,
      textdiff: (t, e, n, r) =>
        `text diff${
          void 0 === r
            ? ""
            : "number" == typeof r
            ? ` at index ${r}`
            : ` at property ${nt(r)}`
        }, format is <a href="https://code.google.com/p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>`,
    },
    it = function (t, e) {
      const n = this.getDeltaType(e),
        r = rt[n],
        i = r && r.apply(r, Array.prototype.slice.call(arguments, 1));
      let s = JSON.stringify(e, null, 2);
      "textdiff" === n && (s = s.split("\\n").join('\\n"+\n   "')),
        t.indent(),
        t.row(s, i),
        t.indent(-1);
    };
  let st;
  (et.prototype.format_added = it),
    (et.prototype.format_modified = it),
    (et.prototype.format_deleted = it),
    (et.prototype.format_moved = it),
    (et.prototype.format_textdiff = it);
  var ot = Object.freeze({
    __proto__: null,
    default: et,
    format: function (t, e) {
      return st || (st = new et()), st.format(t, e);
    },
  });
  const at = "add",
    lt = "remove",
    ft = "replace",
    ht = "move";
  class ct extends J {
    constructor() {
      super(), (this.includeMoveDestinations = !0);
    }
    prepareContext(t) {
      super.prepareContext(t),
        (t.result = []),
        (t.path = []),
        (t.pushCurrentOp = function (t) {
          const { op: e, value: n } = t,
            r = { op: e, path: this.currentPath() };
          void 0 !== n && (r.value = n), this.result.push(r);
        }),
        (t.pushMoveOp = function (t) {
          const e = this.currentPath();
          this.result.push({ op: ht, from: e, path: this.toPath(t) });
        }),
        (t.currentPath = function () {
          return `/${this.path.join("/")}`;
        }),
        (t.toPath = function (t) {
          const e = this.path.slice();
          return (e[e.length - 1] = t), `/${e.join("/")}`;
        });
    }
    typeFormattterErrorFormatter(t, e) {
      t.out(`[ERROR] ${e}`);
    }
    rootBegin() {}
    rootEnd() {}
    nodeBegin(t, e, n) {
      let { path: r } = t;
      r.push(n);
    }
    nodeEnd(t) {
      let { path: e } = t;
      e.pop();
    }
    format_unchanged() {}
    format_movedestination() {}
    format_node(t, e, n) {
      this.formatDeltaChildren(t, e, n);
    }
    format_added(t, e) {
      t.pushCurrentOp({ op: at, value: e[0] });
    }
    format_modified(t, e) {
      t.pushCurrentOp({ op: ft, value: e[1] });
    }
    format_deleted(t) {
      t.pushCurrentOp({ op: lt });
    }
    format_moved(t, e) {
      const n = e[1];
      t.pushMoveOp(n);
    }
    format_textdiff() {
      throw new Error("Not implemented");
    }
    format(t, e) {
      const n = {};
      return this.prepareContext(n), this.recurse(n, t, e), n.result;
    }
  }
  const ut = (t) => t[t.length - 1],
    dt = (t) => {
      return (
        (n = (t, e) => {
          const n = t.path.split("/"),
            r = e.path.split("/");
          return n.length !== r.length
            ? n.length - r.length
            : ((t, e) => {
                const n = parseInt(t, 10),
                  r = parseInt(e, 10);
                return isNaN(n) || isNaN(r) ? 0 : r - n;
              })(ut(n), ut(r));
        }),
        (e = t).sort(n),
        e
      );
      var e, n;
    },
    pt = (t, e) => {
      const n = Array(e.length + 1)
        .fill()
        .map(() => []);
      return t
        .map((t) => {
          let n = e.map((e) => e(t)).indexOf(!0);
          return n < 0 && (n = e.length), { item: t, position: n };
        })
        .reduce((t, e) => (t[e.position].push(e.item), t), n);
    },
    gt = (t) => {
      let { op: e } = t;
      return "move" === e;
    },
    mt = (t) => {
      let { op: e } = t;
      return "remove" === e;
    };
  let vt;
  const yt = (t, e) => (
    vt || (vt = new ct()),
    ((t) => {
      const [e, n, r] = pt(t, [gt, mt]);
      return [...dt(n), ...e, ...r];
    })(vt.format(t, e))
  );
  var _t = Object.freeze({
    __proto__: null,
    default: ct,
    format: yt,
    log: (t, e) => {
      console.log(yt(t, e));
    },
    partitionOps: pt,
  });
  function xt(t) {
    return (
      (e && e[t]) ||
      function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return e;
      }
    );
  }
  const bt = {
    added: xt("green"),
    deleted: xt("red"),
    movedestination: xt("gray"),
    moved: xt("yellow"),
    unchanged: xt("gray"),
    error: xt("white.bgRed"),
    textDiffLine: xt("gray"),
  };
  class wt extends J {
    constructor() {
      super(), (this.includeMoveDestinations = !1);
    }
    prepareContext(t) {
      super.prepareContext(t),
        (t.indent = function (t) {
          (this.indentLevel = (this.indentLevel || 0) + (void 0 === t ? 1 : t)),
            (this.indentPad = new Array(this.indentLevel + 1).join("  ")),
            this.outLine();
        }),
        (t.outLine = function () {
          this.buffer.push(`\n${this.indentPad || ""}`);
        }),
        (t.out = function () {
          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
          for (let t = 0, n = e.length; t < n; t++) {
            let n = e[t].split("\n").join(`\n${this.indentPad || ""}`);
            this.color && this.color[0] && (n = this.color[0](n)),
              this.buffer.push(n);
          }
        }),
        (t.pushColor = function (t) {
          (this.color = this.color || []), this.color.unshift(t);
        }),
        (t.popColor = function () {
          (this.color = this.color || []), this.color.shift();
        });
    }
    typeFormattterErrorFormatter(t, e) {
      t.pushColor(bt.error), t.out(`[ERROR]${e}`), t.popColor();
    }
    formatValue(t, e) {
      t.out(JSON.stringify(e, null, 2));
    }
    formatTextDiffString(t, e) {
      const n = this.parseTextDiff(e);
      t.indent();
      for (let e = 0, r = n.length; e < r; e++) {
        const i = n[e];
        t.pushColor(bt.textDiffLine),
          t.out(`${i.location.line},${i.location.chr} `),
          t.popColor();
        const s = i.pieces;
        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e];
          t.pushColor(bt[n.type]), t.out(n.text), t.popColor();
        }
        e < r - 1 && t.outLine();
      }
      t.indent(-1);
    }
    rootBegin(t, e, n) {
      t.pushColor(bt[e]),
        "node" === e && (t.out("array" === n ? "[" : "{"), t.indent());
    }
    rootEnd(t, e, n) {
      "node" === e && (t.indent(-1), t.out("array" === n ? "]" : "}")),
        t.popColor();
    }
    nodeBegin(t, e, n, r, i) {
      t.pushColor(bt[r]),
        t.out(`${n}: `),
        "node" === r && (t.out("array" === i ? "[" : "{"), t.indent());
    }
    nodeEnd(t, e, n, r, i, s) {
      "node" === r &&
        (t.indent(-1), t.out("array" === i ? "]" : "}" + (s ? "" : ","))),
        s || t.outLine(),
        t.popColor();
    }
    format_unchanged(t, e, n) {
      void 0 !== n && this.formatValue(t, n);
    }
    format_movedestination(t, e, n) {
      void 0 !== n && this.formatValue(t, n);
    }
    format_node(t, e, n) {
      this.formatDeltaChildren(t, e, n);
    }
    format_added(t, e) {
      this.formatValue(t, e[0]);
    }
    format_modified(t, e) {
      t.pushColor(bt.deleted),
        this.formatValue(t, e[0]),
        t.popColor(),
        t.out(" => "),
        t.pushColor(bt.added),
        this.formatValue(t, e[1]),
        t.popColor();
    }
    format_deleted(t, e) {
      this.formatValue(t, e[0]);
    }
    format_moved(t, e) {
      t.out(`==> ${e[1]}`);
    }
    format_textdiff(t, e) {
      this.formatTextDiffString(t, e[0]);
    }
  }
  let jt;
  const Dt = (t, e) => (jt || (jt = new wt()), jt.format(t, e));
  var Mt = Object.freeze({
      __proto__: null,
      default: wt,
      format: Dt,
      log: function (t, e) {
        console.log(Dt(t, e));
      },
    }),
    At = Object.freeze({
      __proto__: null,
      annotated: ot,
      base: K,
      console: Mt,
      html: tt,
      jsonpatch: _t,
    });
  let $t;
  (t.DiffPatcher = q),
    (t.clone = function () {
      return $t || ($t = new q()), $t.clone.apply($t, arguments);
    }),
    (t.console = Mt),
    (t.create = function (t) {
      return new q(t);
    }),
    (t.dateReviver = function (t, e) {
      let n;
      return "string" == typeof e &&
        ((n =
          /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(
            e
          )),
        n)
        ? new Date(
            Date.UTC(+n[1], +n[2] - 1, +n[3], +n[4], +n[5], +n[6], +(n[7] || 0))
          )
        : e;
    }),
    (t.diff = function () {
      return $t || ($t = new q()), $t.diff.apply($t, arguments);
    }),
    (t.formatters = At),
    (t.patch = function () {
      return $t || ($t = new q()), $t.patch.apply($t, arguments);
    }),
    (t.reverse = function () {
      return $t || ($t = new q()), $t.reverse.apply($t, arguments);
    }),
    (t.unpatch = function () {
      return $t || ($t = new q()), $t.unpatch.apply($t, arguments);
    });
});
//# sourceMappingURL=/sm/d38eaa61bf65994bff5a7260846052c149b75b3590a44bdffbc6864deb19050b.map
